# 文件预览关闭问题修复记录

## 问题描述

**问题现象**：当用户打开文件预览后关闭模态框时，前端仍然继续接收后端发送的文件数据，没有发送停止指令给后端。

**影响**：
- 造成不必要的网络流量
- 浪费服务器资源
- 可能影响应用性能
- 用户体验不佳

## 问题分析

### 根本原因
1. **前端状态管理问题**：关闭预览时没有正确通知后端停止传输
2. **监听器清理问题**：WebSocket消息监听器没有被正确移除
3. **请求ID管理问题**：当前请求ID可能没有被正确设置或清理

### 技术细节
- 文件预览通过WebSocket分段传输实现
- 后端使用`sendSegmentedFileViewResponse`函数分段发送数据
- 前端使用`handleFileViewResponse`函数处理接收的数据
- 取消机制通过`file_view_cancel`消息实现

## 修复尝试历史

### 第一次修复 (2024-01-XX)
**修复内容**：
- 在`FileViewer.tsx`的重置状态`useEffect`中添加`notifyBackendStopTransmission`调用
- 确保在`visible`变为`false`时发送取消请求

**修复代码**：
```typescript
useEffect(() => {
    if (!visible) {
        if (currentRequestRef.current) {
            notifyBackendStopTransmission(currentRequestRef.current, '用户关闭了预览');
        }
        // 清理状态...
    }
}, [visible, ...]);
```

**结果**：问题仍然存在

### 第二次修复 (2024-01-XX)
**修复内容**：
- 在`loadFileContent`函数中正确设置`currentRequestRef.current = requestId`
- 在`cancelFileLoading`函数中添加后端取消通知
- 添加对`file_view_cancel_response`消息的处理
- 在分段数据处理前检查请求是否仍然有效

**关键修复点**：
```typescript
// 1. 设置当前请求ID
const requestId = `file_view_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
currentRequestRef.current = requestId;

// 2. 处理取消响应
} else if (data.type === 'file_view_cancel_response' && data.data.requestId === requestId) {
    console.log('📄 收到取消确认响应:', data.data.reason);
    // 清理状态...

// 3. 检查请求有效性
if (currentRequestRef.current !== requestId) {
    console.log('📄 忽略已取消请求的分段数据:', requestId);
    return;
}
```

**结果**：问题仍然存在

### 第三次修复 (2024-01-XX)
**修复内容**：
- 添加`messageHandlerRef`用于管理WebSocket监听器引用
- 创建`clearMessageHandler`函数统一清理监听器
- 在组件卸载时也清理监听器
- 添加详细的调试日志

**关键改进**：
```typescript
// 1. 消息处理器引用管理
const messageHandlerRef = useRef<((event: MessageEvent) => void) | null>(null);

// 2. 统一的监听器清理
const clearMessageHandler = useCallback(() => {
    if (messageHandlerRef.current && webSocketRef.current) {
        webSocketRef.current.removeEventListener('message', messageHandlerRef.current);
        messageHandlerRef.current = null;
    }
}, [webSocketRef]);

// 3. 保存监听器引用
messageHandlerRef.current = handleFileViewResponse;
webSocketRef.current.addEventListener('message', handleFileViewResponse);

// 4. 重置状态时清理
if (!visible) {
    if (currentRequestRef.current) {
        notifyBackendStopTransmission(currentRequestRef.current, '用户关闭了预览');
    }
    clearMessageHandler();
    // 其他清理...
}
```

**调试功能**：
- 添加详细的控制台日志输出
- 监控WebSocket连接状态
- 跟踪请求ID设置和清理
- 监控监听器添加和移除

**结果**：问题仍然存在

## 后端取消机制验证

**后端实现确认**：
```go
// 取消请求处理
case "file_view_cancel":
    h.markRequestCancelled(requestData.RequestID)
    
// 分段传输中的取消检查
func (h *ConnectionHandler) sendSegmentedFileViewResponse(...) {
    for i := 0; i < totalSegments; i++ {
        if h.isRequestCancelled(requestId) {
            // 停止传输
            return
        }
        // 发送分段...
    }
}
```

**后端机制**：✅ 已确认正常工作

## 当前状态

- ❌ 问题仍未解决
- ✅ 前端取消机制已实现
- ✅ 后端取消机制已确认
- ✅ 调试日志已添加
- ❓ 需要进一步诊断问题根源

## 下一步诊断计划

### 需要验证的点
1. **前端日志检查**：
   - 关闭预览时是否显示"📄 关闭预览，通知后端停止传输"
   - 是否显示"📄 发送停止传输请求已发送"
   - WebSocket连接状态是否正常

2. **后端日志检查**：
   - 是否接收到`file_view_cancel`请求
   - 是否正确标记请求为已取消
   - 分段循环是否检查到取消状态

3. **时序问题**：
   - 取消请求与分段传输的时序关系
   - 监听器移除与消息接收的时序关系

### 可能的问题方向
1. **网络延迟**：取消请求到达后端时，部分分段可能已经在传输中
2. **前端状态同步**：React状态更新的异步性可能导致时序问题
3. **WebSocket缓冲**：浏览器或服务器端可能有消息缓冲
4. **监听器作用域**：函数作用域问题导致监听器无法正确移除

## 修复提交记录

- `fix(FileViewer): 修复关闭预览时后端继续发送数据的问题` - 第一次修复尝试
- `fix(FileViewer): 完善文件预览关闭时的监听器清理机制` - 第二次修复尝试

## 相关文件

- `mini-web/frontend/src/components/SimpleTerminal/FileViewer.tsx` - 主要修复文件
- `mini-web/backend/internal/api/connection_handler.go` - 后端取消机制

---

**最后更新**：2024-01-XX  
**状态**：问题仍在调查中  
**负责人**：开发团队 